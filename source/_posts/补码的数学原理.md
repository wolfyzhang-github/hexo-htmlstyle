---
title: 补码的数学原理
date: 2022-07-13 16:47:34
updated:
twitter:
---

很久以前有位先驱，他发现我们日常生活中很多问题都可以用「数字」来理解，接着他想到，那是不是说，我们对实际问题中抽象出的「数字」做一些操作之后就可以解决对应的问题了呢？比如，自然界有三种原色光：红、绿、蓝，我们引入一个新概念叫做 RGB 色值 (Red Green Blue)，来量化形容三种色光的相对亮度，亮度最低时记作 0，最高时记作 255，此时红光的色值就是 (255, 0, 0)，三种色光亮度均为 0 即全黑时即为 (0, 0, 0)。我们又知道，红光和绿光按照 1:1 的比例加在一起就成了黄光，也就是说黄光的色值就是 (255, 255, 0)，某种石板蓝的色值就是 (107, 35, 142) ……我们可以仅凭三个数字就能唯一确定某种色光的构成，与此同时，再对这三个数字进行某些操作就可以对特定的色光进行随心所欲的调节！

先驱很激动，因为如果问题可以用操作「数字」的方式来解决的话，那我们岂不是可以设计制造出一种专门操作「数字」的机器来解决千变万化的问题？！如果真制造出来的话，人就只需要把精力用在对现实世界的数学建模上，具体的繁琐又劳累的数学问题就让机器去做就好。

说干就干！但是先驱遇到了一个问题，那就是机器怎么理解数字这种东西呢？我们人可以根据 $0-9$ 本身的意义以及它们的排列组合来辨识数字，可机器显然不容易识别这么多的状态量。如果我们用电压的相对高低来表示数字大小的话，十个数字岂不是就要十种准确的电压高低？这对电路工程师来说也太难了，万一电路出个小错误就有可能引发大问题，我们的数字识别机制是不适合用在机器上的。这个时候，先驱注意到了中国的算盘，算盘只用几个破珠子就表示出了成百上千的数字！对算盘来说，在个位上的珠子就表示 1，个位上一共有 5 个表示 1 的珠子和 2 个表示 5 的珠子，每逢够 5 的时候，5 个表示 1 的珠子就替换成 1 个表示 5 的珠子。也就是说，在算盘上，就是 $7 =  1 + 1 + 5$，$0 = 0$。*此时先驱脑后闪过一道闪电，柯南附体，咔嚓，我懂了！*——算盘上用 0、1 和 5 的组合并加以权值来表示不同的数字，那就是说我们也可以只用 1 和 0 的组合并加以权值来表示数字！再回到例子，就是 $7 = 1 + 1 + 1 + 1 + 1 + 1 + 1$，$0 = 0$。一共就两种状态，电路工程师也好，甚至机械工程师也可以做出来符合标准的机器啊！真应该感谢发明算盘的前辈。

*这种计数方式在 1679 年被德国人莱布尼兹发现，他还专门写了封信寄给当时身在中国北京的两名传教士，希望「二进制」能够引起当时他心目中的「算术爱好者」康熙皇帝的兴趣。*

显然这种机器最适合操作二进制的数据，换句话说，在我们看来的 (107, 35, 142)，在这种机器处理起来，实际上就是 (1101011, 100011, 10001110)，它不关心它处理的是什么，它只关心……呃，它是机器，它什么也不关心，它只不过是忠实地按照人类给它安排的程序一步一步执行罢了，至于最后输出的结果人类怎么看待，它才不操心那个。这机器起个什么名字呢？对数字进行操作不就是计算嘛，就叫「计算机」吧！

确定了计算机中采用二进制来表示数据后，先驱发了愁。要知道，计算机计算机，肯定至少也要能做加减运算的嘛，乘法就是特殊的加，除法就是特殊的减，其余的各种乘方开方等等又都以加减乘除为基础。可以这么说，有了加减，就有了一切。说起来轻松，可实际实现起来可没这么容易！

先驱发愁在哪儿呢？我们小学就知道，减法和负数有着不一般的关系，比如 $1 - 1$，我们可以把它看作 $1 + (-1)$，也可以把它看做 $1 - (+1)$，也就是说，你是要同时设计制造两种运算器件（加、减）然后对正数进行操作呢，还是要只设计制造一种运算器件（加）而操作两种数字呢？前者机器复杂点，人能省点力气不用设计一套新的带符号数字的编码；后者机器简单点，人就还得再设计一套新的带符号数字的编码。机器可不关心它处理的是什么，而且它可能还对人类把它输出的一堆高低电平翻译来翻译去的很奇怪！这个时候，电子工程师替你回答这个问题了，「当然是只用一种器件了，你以为晶体管不花钱的吗？加法器减法器都给你做上，算加法的时候减法器闲着，算减法的时候加法器闲着，你以为晶体管和你的心肌细胞一样还需要交替休息啊？」没办法，那就设计一套带符号数字的编码吧！

对于无符号的非负数而言，计算机内二进制编码基本不是问题——只需要二进制展开就好了，比如 $(5)_{10}$ 就是 $(101)_2$，这种编码方式起个名字就叫「原码」。但是现在我们已经不能只考虑无符号的非负数了，我们必须考虑带符号的所有整数。小数太复杂，未来再考虑吧，现在只考虑整数的问题。那我们直接在原码的基础上加个符号位？比如约定 $+$ 为 $0$，$-$ 为 $1$。那么这个时候 $(5)_{10}$ 就是二进制的 $(0101)_2$，$(-5)_{10}$ 就是 $(1101)_2$，看起来也不错！但是！电子工程师这个时候又炸毛了，「不错个头啊，你看看你这种表示方法能直接用加法器计算减法吗？」睿智如先驱，$5 + (-5) = 0$，但是 $0101 + 1101 = 10010$，这又是多少？先驱慌了，这种新的编码不仅要能表示带符号数字，还得能用加法器计算减法！难度指数级增加！

先驱慌了，先驱慌了，先驱慌了，先驱不知道该怎么办了，其它运算能转化为加减就是因为加减是最基本的啊，加减，一个是添，一个是去，完全相反的两种操作，这怎么互相转化？！难不成要去用那种两种运算模块的设计思路？要承认人的智慧上限而向现实屈服了？设计计算机不就是要用智慧来解决现实问题？现在你屈服了这…….这不是南辕北辙嘛！*此时先驱脑后又闪过一道闪电，柯南附体，咔嚓，我懂了！*——南辕北辙，谁说往北走就到不了南方？绕地球另外的那大半周不就行了？记$北向$为 $+$，$南向$为 $-$，这不就等于是用加法算出了减法的结果？！先驱笑了，中华文明真是博大精深啊！

先驱找到了突破口，马上着手于新编码方式的设计工作。他给数字数值起名为「真值」，比如 $(5)_{10}$ 和 $(101)_2$ 的真值用十进制来表示就是 $(5)_{10}$，该数字在计算机内的表示编码叫「机器码」，比如$(5)_{10}$ 用有符号原码表示就是 $(0101)_2$。显然我们现在需要做的就是找到一种编码，这种编码能同时满足能够表示有符号数和能够支持计算机将减法转化为加法两种要求。先驱意识到，绕地球转圈也好，还是说钟表转动也罢，其实都是一种性质的运算，这种运算在数学上叫做「模」，也就是我们小学学的「余数」。

说到这里，就要说明一下，先驱为什么是先驱呢？其中一个原因就是他总能以一些特殊的视角去看待常人解决不了的难题并解决之。比如此处的「变加为减」的问题，我们首先要做的，就是重新认识一下减法。上文中说过，减法有两种理解，比如 $1 - 1$，我们可以把它看作 $1 + (-1)$，也可以把它看做 $1 - (+1)$，这两种视角下的减法得出的结果是等价的，这个要点再结合「南辕北辙」给我们带来的启发，就是解决这个问题的关键所在！

我们平时使用的单向射线式数轴是没有边界的，同时也没有「有限周期」的概念，所以正向永远无法转换成负向，也就是加法不能转换成减法。那为什么与此同时「北辙」还能达到「南辕」的效果呢？原因就在于首先地球是个球，其次地球的周长是有限的。换句话说，如果地球不是球，或者地球的周长无穷大，那「北辙」也就永远不可能实现「南辕」了。那怎么把数轴和地球的这两个特性对应起来呢？很简单，首先把数轴首尾相连呈圆环，再规定数轴的末端是一个有限的数字就可以了。这个时候，聪明的你也像先驱一样，发现了这玩意儿它不就是个钟表吗？

一般来说，具象的东西比抽象的东西更容易思考，所以下面我们就钟表为例来继续推理。我们要解决的，是 $a + (-b)$ 的问题，把减法转换为加法，也就是说我们需要找到一个在某个像钟表一样的模系统中可以满足 $a + (-b) = a + x$ 的非负数 $x$，比如说，我们把指针顺拨记为 $+$逆拨记为 $-$，那要想把指针从 $10$ 处移至 $6$ 处，要怎么做？显然我们可以逆拨 $4$ 格，也可以顺拨 $8$ 格，而这实质上就对应着在钟表系统中 $10 + (-4) = 10+8$ ！钟表系统的模为 $12$，所以严格意义上来说，应该写作 $10-4=10+8(mod \ 12)$。换句话说，在钟表系统中， $-4$ 和 $+8$ 是等价的，也就是 $-4=8(mod \ 12)$。数学上，可以称之为：在模为 $12$ 的系统中，$8$ 是 $-4$ 的补码。

说了这么多，其实结论很简单：在某个模系统中，减去某个数就等于加上这个数的补码。

那么补码怎么求？算法如何？机器可不认识「补码」两个字，它只会忠实地执行人类给它设计好的程序。从上面的推理中我们其实很容易得出结论：

对任意一个数 $X_T$，$[X_T]_补 = M+X_T(mod \ M)$

自然语言表述就是，在模为 $M$ 的模系统中，$X_T$ 加上系统的模 $M$ 就等于 $X_T$ 的补码。这就是补码的数学算法。那计算机是一个模系统吗？当然是，因为计算机存储器永远只能存储有限的数据，同时最大值上溢时会抛弃进位其余位再补 $0$，这天生就是一个模系统。说来是不是很戏剧性？我们折腾了这么一大圈，还引入了「模系统」和「补码」的概念，想要把减法转换为加法，可最终还是要用减法去计算「补码」……

先驱也又郁闷了，蹲在地上画圈圈，也没什么知心宝贝来安慰他。他正画着圈圈，满心委屈，欲哭而不能的时候，就只好想想自己梦寐以求的机器，那机器里或许有众多的机械部件，叮当作响，轰隆轰隆一番后输出一些数字，这些数字背后就是某些问题的解决方案，机器里可能也不是机械的，它有可能是电气的，各种线缆连接到一起又徐徐分开，仿佛人类大脑的神经突触，里面以光速沟通着各类信息。「人的脑子怎么就这么聪明呢，为什么就会算减法呢？怎么就不简单一点只会算加法呢？机器怎么就不聪明一点呢？你又不是人脑的蛋白质球，真是 too young too simple，怎么就不能有点新功能呢！」*此时先驱脑后闪过一道闪电，柯南附体，咔嚓，我懂了！*——机器里是二进制啊！机器除了加法的数学运算还能做逻辑运算啊！看能不能在逻辑运算上玩出点花样来？

先驱也顾不得爬回桌子上再去演算了，他痛斥自己以前太 naive，趴在地上，开始疯狂计算。先驱以前在纸上写下了一个个凝结着人类伟大智慧的公式，但是后来啥都没剩下，纸张会消失，但就像刘慈欣在《三体》中写下的一样，刻在石头上的字迹不会消失。我们到达现场时，先驱已经不知道怎么回事就从那个地方跑到首都去了，或许还念了两句诗，总之我们只在地上看到这么几行式子：

$[1101100]_补 = 2^8+1101100=100000000+1101100(mod \ 2^8)=01101100$

$[-1101100]_补=2^8-1101100=100000000-1101100=10000000+10000000-1101100=10000000+(1111111-1101100)+1=10000000+0010011+1(mod \ 2^8)=10010100$

我们现在来猜一猜先驱的想法。首先，对正数来说，谈不上补码的概念，因为加法的时候直接加就好，至多把首位符号位至 $0$；而负数，就是我们需要寻找它补码的对象——把加上一个负数转化为加上这个负数的补码。我们可以看到，先驱应该是想用第一个 $10000000$ 来产生最后的符号位 $1$，而第二个 $10000000$ 拆成了 $1111111+1$，$(1111111-1101100)$ 是为了将数值部分的 $1101100$ 各位取反，从而得到最终结果。总结一下，这个思路就是，「符号置一，数值部分，各位取反，末尾加一」。直接置值、取反和加一，这三种操作计算机可熟啊。

先驱长舒一口气，好了，这个能表示带符号数字，还能用加法器计算减法的编码方式终于完成了，这套编码方式就叫「补码」。

回过头来看，我们现在完成了什么工作？确定了计算机采用二进制，实现了有符号整数的编码和加减计算，而一台完整的计算机需要什么？其实，计算机一直在做的事情就是：

```C
// PC 指 program counter，内含存储器地址
while(1){
  从 PC 指示的存储器位置取出指令;
  执行指令;
  更新 PC;
}
```

要实现这个看起来傻傻的功能我们需要什么呢？需要能够存放数据的存储器，需要实现算术和逻辑计算的 ALU（加法器只是其中的一小部分），需要能够把存储器中的二进制位解析成实际控制计算机电路脉冲的控制器（控制器需要控制两股电路脉冲：控制流和数据流），需要承载人机交互功能的输入设备和输出设备，需要能够把这些东西都集成互联到一起的一块大 PCB。

实际上，存储器后来被分化成了 RAM 和 ROM，ALU 和控制器集成到了一小块硅片上后被人们称作 CPU（不然为什么课本上写 CPU 的作用是计算机系统的控制和运算核心），输入输出设备就是各种能够支持你和计算机之间进行信息交换的设备，集成互联这些东西的大 PCB 被叫做 motherboard，即主板。主板上各种设备之间信息流通的电气缆线集结成束，被称作 bus，中文名叫总线。

从二进制开始，到第一台电子计算机出现，先驱还有很长的路要走啊。我们为他加油。

> 附：一台用 C 语言模拟的 8 位计算机，目前只支持 0-255 之间的加法运算。
> GitHub 地址：https://github.com/wolfyzhang-github/YEMUs

```C
/*
 * 假设一个 8 位模型机，有 4 个通用寄存器 r0-r3，有 16 个内存单元 m0-m15.
 * 每个内存单元 ALU、通用寄存器、IR（指令寄存器）、MDR（主存数据寄存器）的宽度都是 8 位.
 * PC 和 MAR（主存地址寄存器）的宽度都是 4 位，总线中有 4 位地址线、8 位数据线和若干位信号线.
 *
 * 该模型机采用 8 位定长指令字，每条指令的长度为 8 位，指令格式有 R 型和 M 型两种.
 *
 * 指令格式：
 *
 *   格式     4 位    2 位   2 位                功能说明
 *   ------------------------------------------------------------------------
 *     R 型 |  op  |  rt  |  rs  | R[rt] <- R[rt] op R[rs]，或 R[rt] <- R[rs]
 *   ------------------------------------------------------------------------
 *     M 型 |  op  |    addr     | R[0] <- M[addr]，或 M[addr] <- R[0]
 *
 *   op：指令类型，取值为mov、add、load 或 store.
 *
 * 指令手册：
 *
 *      汇编指令           数据指令               功能类型     内存信息
 *  ------------------------------------------------------------------
 *    mov   rt,rs  |  R[rt] <- R[rs]          |  R 型  |  0000 rt rs
 *  ------------------------------------------------------------------
 *    add   rt,rs  |  R[rt] <- R[rs] + R[rt]  |  R 型  |  0001 rt rs
 *  ------------------------------------------------------------------
 *    load  addr   |  R[0] <- M[addr]         |  M 型  |  1110 addr
 *  ------------------------------------------------------------------
 *    store addr   |  M[addr] <- R[0]         |  M 型  |  1111 addr
 *
 * 如下实现了一个该模型机的指令执行器.
 */

#include <stdint.h>
#include <stdio.h>

#define NREG 4   // 寄存器位宽
#define NMEM 16  // 内存位宽


/*
 * 操作数译码的实现宏
 * 说明：操作数译码即从指令中提取出操作数.
 *      以 DECODE_R(inst) 为例，inst 为传入参数，即指令.
 *
 *      该宏定义了两个 uint8_t 变量 rt 和 rs（ 8 位无符号），用于存放操作数.
 *      利用指令格式 union 中 struct 的成员来获取操作数并赋值给 rt 和 rs.
 */
#define DECODE_R(inst) uint8_t rt = (inst).rtype.rt, rs = (inst).rtype.rs
#define DECODE_M(inst) uint8_t addr = (inst).mtype.addr

/*
 * 定义指令格式（即指令模板）
 * 说明：uint8_t 实际为 unsigned char 类型，即 8 位无符号整数，以此来代表对应寄存器中的数据.
 *      定义一个新的数据类型 inst_t，具体构造为一个 union.
 *      union 中的成员变量为 2 个 struct 和 1 个 uint8_t.
 *
 *      rtype 结构变量代表 R 型指令，mtype 结构变量代表 M 型指令，以下以 rtype 为例.
 *      rtype 的成员变量为：op、rt 和 rs，分别占用各自的位字段，共 8 位，即一个 uint8_t 类型的长度.
 *
 *      指令格式通过 struct 描述，但我们还需要一个 8 位的变量 inst 来存储指令的内容（指代存放指令的内存），
 *      之后利用 struct 中的成员变量来解析指令中的不同部分（利用 struct 描述的指令格式）.
 *
 *      union 中所有成员占用同一块内存，可利用它的这个性质，首先将指令写入（假定指令存储变量为 this）this.inst 中，
 *      然后通过 this.rtype.op 和 this.rtype.rt 即可获取指令操作码和操作数.
 *      即对于同一块内存，this.inst 和 this.rtype.op 和 this.rtype.rt 可以互相访问，
 *      我们是以变化的视角来看待这块不变的内存.
 */
typedef union {
    struct { uint8_t rs : 2, rt : 2, op : 4; } rtype;
    struct { uint8_t addr : 4      , op : 4; } mtype;
    uint8_t inst;
} inst_t;

/*
 * 定义存储器
 */
uint8_t pc = 0;         // PC，C 语言中没有 4 位的数据类型，采用 8 位类型来表示
uint8_t R[NREG] = {};   // 寄存器，一个长度为 NREG 的 uint8_t 数组
uint8_t M[NMEM] = {     // 内存，一个长度为 NMEM 的 uint8_t 数组，其中包含一个计算 z = x + y 的程序，x、y 均已定义
        0b11100110,  // load  r0, 6# | R[0] <- M[6] = y
        0b00000100,  // mov   r1, r0 | R[1] <- R[0]
        0b11100101,  // load  r0, 5# | R[0] <- M[5] = x
        0b00010001,  // add   r0, r1 | R[0] <- R[0] + R[1]
        0b11110111,  // store 7#, r0 | M[7] = z <- R[0]
        0b00010000,  // x = 16
        0b00100001,  // y = 33
        0b00000000,  // z = 0
};

int halt = 0;           // 结束标志

/*
 * 执行一条指令
 */
void exec_once() {
    inst_t this;        // 定义当下执行的指令，即指令存储变量，实质上它指代的是一块内存，其中存储了一条指令
    this.inst = M[pc];  // 从 pc 指向内存地址（该内存数组的索引）的存储单元中读取一条指令，
                        // 并将上述内存视作一个 uint8_t 变量，将取到的指令赋值给其，
                        // 留待后续利用该 union 中 struct 的成员变量来解析指令中的不同部分.
    switch (this.rtype.op) {
        //   操作码译码  操作数译码       执行
        case 0b0000: { DECODE_R(this); R[rt]   = R[rs];                  break; }
        case 0b0001: { DECODE_R(this); R[rt]  += R[rs];                  break; }
        case 0b1110: { DECODE_M(this); R[0]    = M[addr];                break; }
        case 0b1111: { DECODE_M(this); M[addr] = R[0]; halt = 1; pc = -1; break; }
        default:
            printf("Invalid instruction with opcode = %x, halting...\n", this.rtype.op);
            halt = 1;
            break;
    }
    pc++; // 更新PC
}

/*
 * 入口程序
 * 说明：main() 中包含一个死循环，循环体中调用 exec_once() 来执行一条指令.
 *      直至 halt 为 1，即有结束标志时，循环结束，输出计算结果.
 */
int main() {
    unsigned int x, y;
    uint8_t x_t, y_t;
    char buff;

    printf("8 bits computer simulator v1.0, currently only supports addition.\n");
    while (1) {
        printf("Please enter the first operand(0-255): ");
        scanf("%u", &x);
        printf("Please enter the second operand(0-255): ");
        scanf("%u", &y);
        if ((x + y)> 255) {
            printf("The result is too large, please try again.\n");
            continue;
        }
        M[5] = (x_t = x);
        M[6] = (y_t = y);
        while (1) {
            exec_once();
            if (halt) break;
        }
        printf("The result of %d + %d is %d\n", M[5], M[6], M[7]);
        halt = 0;
    }
    return 0;
}
```

**本文从袁春风教授、余子豪博士主编的《计算机系统基础》中有极大受益。**
