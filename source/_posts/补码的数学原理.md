---
title: 补码的数学原理
date: 2022-07-13 16:47:34
updated:
twitter:
---

很久以前有位先驱，他发现我们日常生活中很多问题都可以用「数字」来理解，接着他想到，那是不是说，我们对实际问题中抽象出的「数字」做一些操作之后就可以解决对应的问题了呢？比如，自然界有三种原色光：红、绿、蓝，我们引入一个新概念叫做 RGB 色值 (Red Green Blue)，来量化形容三种色光的相对亮度，亮度最低时记作 0，最高时记作 255，此时红光的色值就是 (255, 0, 0)，三种色光亮度均为 0 即全黑时即为 (0, 0, 0)。我们又知道，红光和绿光按照 1:1 的比例加在一起就成了黄光，也就是说黄光的色值就是 (255, 255, 0)，某种石板蓝的色值就是 (107, 35, 142) ……我们可以仅凭三个数字就能唯一确定某种色光的构成，与此同时，再对这三个数字进行某些操作就可以对特定的色光进行随心所欲的调节！

先驱很激动，因为如果问题可以用操作「数字」的方式来解决的话，那我们岂不是可以设计制造出一种专门操作「数字」的机器来解决千变万化的问题？！如果真制造出来的话，人就只需要把精力用在对现实世界的数学建模上，具体的繁琐又劳累的数学问题就让机器去做就好。

说干就干！但是先驱遇到了一个问题，那就是机器怎么理解数字这种东西呢？我们人可以根据 $0-9$ 本身的意义以及它们的排列组合来辨识数字，可机器显然不容易识别这么多的状态量。如果我们用电压的相对高低来表示数字大小的话，十个数字岂不是就要十种准确的电压高低？这对电路工程师来说也太难了，万一电路出个小错误就有可能引发大问题，我们的数字识别机制是不适合用在机器上的。这个时候，先驱注意到了中国的算盘，算盘只用几个破珠子就表示出了成百上千的数字！对算盘来说，在个位上的珠子就表示 1，个位上一共有 5 个表示 1 的珠子和 2 个表示 5 的珠子，每逢够 5 的时候，5 个表示 1 的珠子就替换成 1 个表示 5 的珠子。也就是说，在算盘上，就是 $7 =  1 + 1 + 5$，$0 = 0$。*此时先驱脑后闪过一道闪电，柯南附体，咔嚓，我懂了！*——算盘上用 0、1 和 5 的组合并加以权值来表示不同的数字，那就是说我们也可以只用 1 和 0 的组合并加以权值来表示数字！再回到例子，就是 $7 = 1 + 1 + 1 + 1 + 1 + 1 + 1$，$0 = 0$。一共就两种状态，电路工程师也好，甚至机械工程师也可以做出来符合标准的机器啊！真应该感谢发明算盘的前辈。

*这种计数方式在 1679 年被德国人莱布尼兹发现，他还专门写了封信寄给当时身在中国北京的两名传教士，希望「二进制」能够引起当时他心目中的「算术爱好者」康熙皇帝的兴趣。*

显然这种机器最适合操作二进制的数据，换句话说，在我们看来的 (107, 35, 142)，在这种机器处理起来，实际上就是 (1101011, 100011, 10001110)，它不关心它处理的是什么，它只关心……呃，它是机器，它什么也不关心，它只不过是忠实地按照人类给它安排的程序一步一步执行罢了，至于最后输出的结果人类怎么看待，它才不操心那个。这机器起个什么名字呢？对数字进行操作不就是计算嘛，就叫「计算机」吧！

确定了计算机中采用二进制来表示数据后，先驱发了愁。要知道，计算机计算机，肯定至少也要能做加减运算的嘛，乘法就是特殊的加，除法就是特殊的减，其余的各种乘方开方等等又都以加减乘除为基础。可以这么说，有了加减，就有了一切。说起来轻松，可实际实现起来可没这么容易！

先驱发愁在哪儿呢？我们小学就知道，减法和负数有着不一般的关系，比如 $1 - 1$，我们可以把它看作 $1 + (-1)$，也可以把它看做 $1 - (+1)$，也就是说，你是要同时设计制造两种运算器件（加、减）然后对正数进行操作呢，还是要只设计制造一种运算器件（加）而操作两种数字呢？前者机器复杂点，人能省点力气不用设计一套新的带符号数字的编码；后者机器简单点，人就还得再设计一套新的带符号数字的编码。机器可不关心它处理的是什么，而且它可能还对人类把它输出的一堆高低电平翻译来翻译去的很奇怪！这个时候，电子工程师替你回答这个问题了，「当然是只用一种器件了，你以为晶体管不花钱的吗？加法器减法器都给你做上，算加法的时候减法器闲着，算减法的时候加法器闲着，你以为晶体管和你的心肌细胞一样还需要交替休息啊？」没办法，那就设计一套带符号数字的编码吧！

对于无符号的非负数而言，计算机内二进制编码基本不是问题——只需要二进制展开就好了，比如 $(5)_{10}$ 就是 $(101)_2$，这种编码方式起个名字就叫「原码」。但是现在我们已经不能只考虑无符号的非负数了，我们必须考虑带符号的所有整数。小数太复杂，未来再考虑吧，现在只考虑整数的问题。那我们直接在原码的基础上加个符号位？比如约定 $+$ 为 $0$，$-$ 为 $1$。那么这个时候 $(5)_{10}$ 就是二进制的 $(0101)_2$，$(-5)_{10}$ 就是 $(1101)_2$，看起来也不错！但是！电子工程师这个时候又炸毛了，「不错个头啊，你看看你这种表示方法能直接用加法器计算减法吗？」睿智如先驱，$5 + (-5) = 0$，但是 $0101 + 1101 = 10010$，这又是多少？先驱慌了，这种新的编码不仅要能表示带符号数字，还得能用加法器计算减法！难度指数级增加！

先驱慌了，先驱慌了，先驱慌了，先驱不知道该怎么办了，其它运算能转化为加减就是因为加减是最基本的啊，加减，一个是添，一个是去，完全相反的两种操作，这怎么互相转化？！难不成要去用那种两种运算模块的设计思路？要承认人的智慧上限而向现实屈服了？设计计算机不就是要用智慧来解决现实问题？现在你屈服了这…….这不是南辕北辙嘛！*此时先驱脑后又闪过一道闪电，柯南附体，咔嚓，我懂了！*——南辕北辙，谁说往北走就到不了南方？绕地球另外的那大半周不就行了？记$北向$为 $+$，$南向$为 $-$，这不就等于是用加法算出了减法的结果？！先驱笑了，中华文明真是博大精深啊！

先驱找到了突破口，马上着手于新编码方式的设计工作。他给数字数值起名为「真值」，比如 $(5)_{10}$ 和 $(101)_2$ 的真值用十进制来表示就是 $(5)_{10}$，该数字在计算机内的表示编码叫「机器码」，比如$(5)_{10}$ 用有符号原码表示就是 $(0101)_2$。显然我们现在需要做的就是找到一种编码，这种编码能同时满足能够表示有符号数和能够支持计算机将减法转化为加法两种要求。先驱意识到，绕地球转圈也好，还是说钟表转动也罢，其实都是一种性质的运算，这种运算在数学上叫做「模」，也就是我们小学学的「余数」。

我们可以把钟表理解为一个环形数轴，该数轴以 $0$ 为起点，环绕一周，以 $12$ 为终点，同时 $12$ 与 $0$ 重合。在钟表这个系统中，我们如果想把指针从 $10$ 处拨至 $6$ 处，有两种方法，一种是 $ 10 - 4 = 6 $ 即逆时针拨动 $4$ 个单位长度，另一种是 $10 + 8 = 18$ 即顺时针拨动 $8$ 个单位长度。下面就是灵魂发问——为什么 $6$ 和 $18$ 是同一位置？答案很简单，因为 $18 = 6 (mod \ 12)$ ，$6$ 就是 $18$ 模 $12$ 的结果，所以在钟表系统中 $6$ 和 $18$ 等价。换句话说，我们在钟表系统中进行的顺拨操作，可以理解为加，逆拨操作，可以理解为减，我们现在要做的就是用加来取代减，所以必须找到新的「加数」来取代原来的「减数」，比如， $ 10 - 4 = 6 $ ，我们要做的就是找到  $8$ 这个数字来实现 $10 + 8 = 18$ 的效果。

在这里我们会有一个朴素的直觉性质的想法，就是需要找的这个数字一定要「加过头」，加到大于钟表系统的模数 $12$ 才行，用专业语言讲，叫发生「上溢」，此时得到的结果就是原始运算结果再模 $12$ 的—— $10 + 8 = 18 = 6(mod \ 12)$ ——结果。那为什么我们的直线数轴不会有这样的现象呢？因为直线数轴是个无穷数集，不存在有限数集的表示范围的概念，也就不会有「加过头」的事情发生，它根本就不是一个模系统！总之，对于模系统来说，我们可以找到某个数字来作为新的「加数」而取代「减数」，这个数字在数学上就叫做原来减数的补码。

> 太晚了，留待未来更新……
